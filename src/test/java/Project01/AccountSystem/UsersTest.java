package Project01.AccountSystem;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.io.TempDir;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

import static org.junit.jupiter.api.Assertions.*;

/**
 * ClassName: UsersTest
 * Description: 账户系统稳定性测试类
 * 
 * 测试覆盖：
 * 1. 用户对象创建和属性设置
 * 2. 存取款功能
 * 3. 余额计算和持久化
 * 4. 文件读写操作
 * 5. 边界条件和异常情况
 * 
 * @Author Liang-ht
 * @Create 2025-12-01
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class UsersTest {

    private Users testUser;
    private static final String TEST_USER_NAME = "testUser";
    private static final String TEST_PASSWORD = "password123";
    private static final long TEST_ID = 1733000000000L;
    
    // 备份原始文件路径
    private static final String ACCOUNT_DETAIL_PATH = "src/main/resources/Project01/AccountDetail.csv";
    private static final String ACCOUNT_DETAIL_BACKUP = "src/main/resources/Project01/AccountDetail.csv.backup";

    @BeforeAll
    static void setUpClass() {
        System.out.println("========================================");
        System.out.println("开始账户系统稳定性测试");
        System.out.println("========================================\n");
        
        // 备份原始数据文件
        backupFile(ACCOUNT_DETAIL_PATH, ACCOUNT_DETAIL_BACKUP);
    }

    @AfterAll
    static void tearDownClass() {
        System.out.println("\n========================================");
        System.out.println("账户系统稳定性测试完成");
        System.out.println("========================================");
        
        // 恢复原始数据文件
        restoreFile(ACCOUNT_DETAIL_BACKUP, ACCOUNT_DETAIL_PATH);
    }

    @BeforeEach
    void setUp() {
        // 每个测试前创建新的用户对象
        testUser = new Users(TEST_USER_NAME, TEST_PASSWORD);
        testUser.setId(TEST_ID);
    }

    @AfterEach
    void tearDown() {
        testUser = null;
    }

    // ==================== 基础功能测试 ====================

    @Test
    @Order(1)
    @DisplayName("测试1: 用户对象创建")
    void testUserCreation() {
        System.out.println("\n【测试1】用户对象创建测试");
        
        assertNotNull(testUser, "用户对象不应为空");
        assertEquals(TEST_USER_NAME, testUser.getName(), "用户名应该匹配");
        assertEquals(TEST_PASSWORD, testUser.getPassword(), "密码应该匹配");
        assertEquals(TEST_ID, testUser.getId(), "用户ID应该匹配");
        
        System.out.println("✓ 用户对象创建成功");
        System.out.println("  - 用户名: " + testUser.getName());
        System.out.println("  - ID: " + testUser.getId());
    }

    @Test
    @Order(2)
    @DisplayName("测试2: 用户ID自动生成")
    void testAutoGeneratedId() {
        System.out.println("\n【测试2】用户ID自动生成测试");
        
        Users newUser = new Users("autoUser", "pass123");
        long generatedId = newUser.getId();
        
        assertTrue(generatedId > 0, "自动生成的ID应该大于0");
        assertTrue(generatedId <= System.currentTimeMillis(), "ID应该是有效的时间戳");
        
        System.out.println("✓ ID自动生成成功: " + generatedId);
    }

    @Test
    @Order(3)
    @DisplayName("测试3: toString方法格式")
    void testToStringFormat() {
        System.out.println("\n【测试3】toString方法格式测试");
        
        String result = testUser.toString();
        String expected = TEST_USER_NAME + "," + TEST_PASSWORD + "," + TEST_ID;
        
        assertEquals(expected, result, "toString格式应该正确");
        assertTrue(result.contains(","), "应该包含逗号分隔符");
        
        String[] parts = result.split(",");
        assertEquals(3, parts.length, "应该有3个部分");
        
        System.out.println("✓ toString格式正确: " + result);
    }

    @Test
    @Order(4)
    @DisplayName("测试4: 时间格式获取")
    void testGetTime() {
        System.out.println("\n【测试4】时间格式获取测试");
        
        String time = testUser.getTime();
        
        assertNotNull(time, "时间不应为空");
        assertTrue(time.matches("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}"), 
                   "时间格式应该是 yyyy-MM-dd HH:mm:ss");
        
        System.out.println("✓ 时间格式正确: " + time);
    }

    // ==================== 存取款功能测试 ====================

    @Test
    @Order(5)
    @DisplayName("测试5: 存款功能")
    void testSaveMoney() {
        System.out.println("\n【测试5】存款功能测试");
        
        double initialBalance = testUser.getBalance();
        double depositAmount = 1000.0;
        
        testUser.saveMoney(depositAmount);
        
        assertEquals(initialBalance + depositAmount, testUser.getBalance(), 0.01, 
                     "存款后余额应该增加");
        
        System.out.println("✓ 存款成功");
        System.out.println("  - 存入金额: " + depositAmount);
        System.out.println("  - 当前余额: " + testUser.getBalance());
    }

    @Test
    @Order(6)
    @DisplayName("测试6: 取款功能")
    void testWithdrawMoney() {
        System.out.println("\n【测试6】取款功能测试");
        
        // 先存入一些钱
        testUser.saveMoney(1000.0);
        double balanceAfterDeposit = testUser.getBalance();
        
        double withdrawAmount = 300.0;
        testUser.withdrawMoney(withdrawAmount);
        
        assertEquals(balanceAfterDeposit - withdrawAmount, testUser.getBalance(), 0.01, 
                     "取款后余额应该减少");
        
        System.out.println("✓ 取款成功");
        System.out.println("  - 取出金额: " + withdrawAmount);
        System.out.println("  - 当前余额: " + testUser.getBalance());
    }

    @Test
    @Order(7)
    @DisplayName("测试7: 多次存取款")
    void testMultipleTransactions() {
        System.out.println("\n【测试7】多次存取款测试");
        
        testUser.saveMoney(1000.0);
        testUser.withdrawMoney(200.0);
        testUser.saveMoney(500.0);
        testUser.withdrawMoney(300.0);
        
        double expectedBalance = 1000.0 - 200.0 + 500.0 - 300.0;
        assertEquals(expectedBalance, testUser.getBalance(), 0.01, 
                     "多次交易后余额应该正确");
        
        System.out.println("✓ 多次交易成功");
        System.out.println("  - 最终余额: " + testUser.getBalance());
        System.out.println("  - 预期余额: " + expectedBalance);
    }

    @Test
    @Order(8)
    @DisplayName("测试8: 小数金额处理")
    void testDecimalAmounts() {
        System.out.println("\n【测试8】小数金额处理测试");
        
        testUser.saveMoney(123.45);
        testUser.saveMoney(67.89);
        
        double expectedBalance = 123.45 + 67.89;
        assertEquals(expectedBalance, testUser.getBalance(), 0.01, 
                     "小数金额应该正确处理");
        
        System.out.println("✓ 小数金额处理正确");
        System.out.println("  - 当前余额: " + testUser.getBalance());
    }

    // ==================== 余额持久化测试 ====================

    @Test
    @Order(9)
    @DisplayName("测试9: 从文件加载最新余额")
    void testGetLastestBalance() {
        System.out.println("\n【测试9】从文件加载最新余额测试");
        
        // 使用测试数据中的ID
        double balance = testUser.getLastestBalance(TEST_ID);
        
        assertTrue(balance >= 0, "余额应该大于等于0");
        
        System.out.println("✓ 余额加载成功: " + balance);
    }

    @Test
    @Order(10)
    @DisplayName("测试10: 余额持久化验证")
    void testBalancePersistence() {
        System.out.println("\n【测试10】余额持久化验证测试");
        
        // 执行存款操作
        testUser.saveMoney(888.88);
        double savedBalance = testUser.getBalance();
        
        // 创建新用户对象，模拟重新登录
        Users newUser = new Users(TEST_USER_NAME, TEST_PASSWORD);
        newUser.setId(TEST_ID);
        
        // 从文件加载余额
        double loadedBalance = newUser.getLastestBalance(TEST_ID);
        
        assertEquals(savedBalance, loadedBalance, 0.01, 
                     "重新加载的余额应该与保存的余额一致");
        
        System.out.println("✓ 余额持久化验证成功");
        System.out.println("  - 保存的余额: " + savedBalance);
        System.out.println("  - 加载的余额: " + loadedBalance);
    }

    // ==================== 文件操作测试 ====================

    @Test
    @Order(11)
    @DisplayName("测试11: 明细文件写入")
    void testWriteFile() {
        System.out.println("\n【测试11】明细文件写入测试");
        
        String testData = TEST_ID + ",2025-12-01 16:00:00,+999.0,测试存入,999.0\n";
        
        assertDoesNotThrow(() -> testUser.writeFile(testData), 
                          "写入文件不应该抛出异常");
        
        // 验证文件是否包含写入的数据
        boolean found = false;
        try (BufferedReader br = new BufferedReader(new FileReader(ACCOUNT_DETAIL_PATH))) {
            String line;
            while ((line = br.readLine()) != null) {
                if (line.contains("测试存入")) {
                    found = true;
                    break;
                }
            }
        } catch (IOException e) {
            fail("读取文件失败: " + e.getMessage());
        }
        
        assertTrue(found, "写入的数据应该在文件中");
        System.out.println("✓ 文件写入成功");
    }

    @Test
    @Order(12)
    @DisplayName("测试12: 明细文件读取")
    void testReadFile() {
        System.out.println("\n【测试12】明细文件读取测试");
        
        // 先写入一些测试数据
        testUser.saveMoney(555.55);
        
        // 捕获控制台输出
        ByteArrayOutputStream outContent = new ByteArrayOutputStream();
        PrintStream originalOut = System.out;
        System.setOut(new PrintStream(outContent));
        
        assertDoesNotThrow(() -> testUser.readFile(), 
                          "读取文件不应该抛出异常");
        
        // 恢复控制台输出
        System.setOut(originalOut);
        
        String output = outContent.toString();
        System.out.println("✓ 文件读取成功");
        System.out.println("  读取到的记录数: " + (output.split("\n").length - 1));
    }

    // ==================== 边界条件测试 ====================

    @Test
    @Order(13)
    @DisplayName("测试13: 零金额存款")
    void testZeroDeposit() {
        System.out.println("\n【测试13】零金额存款测试");
        
        double initialBalance = testUser.getBalance();
        testUser.saveMoney(0.0);
        
        assertEquals(initialBalance, testUser.getBalance(), 0.01, 
                     "存入0元后余额不应该变化");
        
        System.out.println("✓ 零金额存款处理正确");
    }

    @Test
    @Order(14)
    @DisplayName("测试14: 大额交易")
    void testLargeTransaction() {
        System.out.println("\n【测试14】大额交易测试");
        
        double largeAmount = 999999999.99;
        testUser.saveMoney(largeAmount);
        
        assertEquals(largeAmount, testUser.getBalance(), 0.01, 
                     "大额存款应该正确处理");
        
        System.out.println("✓ 大额交易处理正确");
        System.out.println("  - 交易金额: " + largeAmount);
    }

    @Test
    @Order(15)
    @DisplayName("测试15: 余额不足取款（负数余额）")
    void testNegativeBalance() {
        System.out.println("\n【测试15】负数余额测试");
        
        testUser.saveMoney(100.0);
        testUser.withdrawMoney(150.0);
        
        assertEquals(-50.0, testUser.getBalance(), 0.01, 
                     "取款超过余额会导致负数余额");
        
        System.out.println("⚠ 警告: 系统允许负数余额");
        System.out.println("  - 当前余额: " + testUser.getBalance());
    }

    @Test
    @Order(16)
    @DisplayName("测试16: 不存在的用户ID查询余额")
    void testNonExistentUserId() {
        System.out.println("\n【测试16】不存在的用户ID查询余额测试");
        
        long nonExistentId = 9999999999999L;
        double balance = testUser.getLastestBalance(nonExistentId);
        
        assertEquals(0.0, balance, 0.01, 
                     "不存在的用户ID应该返回0余额");
        
        System.out.println("✓ 不存在的用户ID处理正确，返回余额: " + balance);
    }

    // ==================== 并发和性能测试 ====================

    @Test
    @Order(17)
    @DisplayName("测试17: 快速连续交易")
    void testRapidTransactions() {
        System.out.println("\n【测试17】快速连续交易测试");
        
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < 10; i++) {
            testUser.saveMoney(10.0);
        }
        
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        
        assertEquals(100.0, testUser.getBalance(), 0.01, 
                     "快速连续交易后余额应该正确");
        
        System.out.println("✓ 快速连续交易测试通过");
        System.out.println("  - 交易次数: 10");
        System.out.println("  - 耗时: " + duration + "ms");
        System.out.println("  - 最终余额: " + testUser.getBalance());
    }

    @Test
    @Order(18)
    @DisplayName("测试18: 属性设置和获取")
    void testGettersAndSetters() {
        System.out.println("\n【测试18】属性设置和获取测试");
        
        testUser.setName("newName");
        assertEquals("newName", testUser.getName(), "名称设置应该生效");
        
        testUser.setPassword("newPassword");
        assertEquals("newPassword", testUser.getPassword(), "密码设置应该生效");
        
        long newId = 1234567890L;
        testUser.setId(newId);
        assertEquals(newId, testUser.getId(), "ID设置应该生效");
        
        System.out.println("✓ 所有属性设置和获取正常");
    }

    // ==================== 异常处理测试 ====================

    @Test
    @Order(19)
    @DisplayName("测试19: 文件不存在时的处理")
    void testFileNotFound() {
        System.out.println("\n【测试19】文件不存在时的处理测试");
        
        // 临时重命名文件
        File originalFile = new File(ACCOUNT_DETAIL_PATH);
        File tempFile = new File(ACCOUNT_DETAIL_PATH + ".temp");
        
        if (originalFile.exists()) {
            originalFile.renameTo(tempFile);
        }
        
        try {
            // 应该不会抛出异常，而是返回0
            double balance = testUser.getLastestBalance(TEST_ID);
            assertEquals(0.0, balance, 0.01, "文件不存在时应该返回0");
            System.out.println("✓ 文件不存在时处理正确");
        } finally {
            // 恢复文件
            if (tempFile.exists()) {
                tempFile.renameTo(originalFile);
            }
        }
    }

    @Test
    @Order(20)
    @DisplayName("测试20: 数据完整性验证")
    void testDataIntegrity() {
        System.out.println("\n【测试20】数据完整性验证测试");
        
        // 执行一系列操作
        testUser.saveMoney(1000.0);
        double balance1 = testUser.getBalance();
        
        testUser.withdrawMoney(300.0);
        double balance2 = testUser.getBalance();
        
        testUser.saveMoney(500.0);
        double balance3 = testUser.getBalance();
        
        // 验证每一步的余额变化
        assertEquals(1000.0, balance1, 0.01);
        assertEquals(700.0, balance2, 0.01);
        assertEquals(1200.0, balance3, 0.01);
        
        // 从文件重新加载验证
        double loadedBalance = testUser.getLastestBalance(TEST_ID);
        assertEquals(balance3, loadedBalance, 0.01, "文件中的余额应该与内存一致");
        
        System.out.println("✓ 数据完整性验证通过");
        System.out.println("  - 内存余额: " + balance3);
        System.out.println("  - 文件余额: " + loadedBalance);
    }

    // ==================== 辅助方法 ====================

    /**
     * 备份文件
     */
    private static void backupFile(String source, String backup) {
        try {
            File sourceFile = new File(source);
            if (sourceFile.exists()) {
                Files.copy(sourceFile.toPath(), 
                          new File(backup).toPath(), 
                          StandardCopyOption.REPLACE_EXISTING);
                System.out.println("✓ 已备份原始数据文件");
            }
        } catch (IOException e) {
            System.err.println("⚠ 备份文件失败: " + e.getMessage());
        }
    }

    /**
     * 恢复文件
     */
    private static void restoreFile(String backup, String target) {
        try {
            File backupFile = new File(backup);
            if (backupFile.exists()) {
                Files.copy(backupFile.toPath(), 
                          new File(target).toPath(), 
                          StandardCopyOption.REPLACE_EXISTING);
                backupFile.delete();
                System.out.println("✓ 已恢复原始数据文件");
            }
        } catch (IOException e) {
            System.err.println("⚠ 恢复文件失败: " + e.getMessage());
        }
    }
}
